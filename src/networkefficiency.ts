/*
This software was developed by employees of the National Institute of Standards and Technology (NIST), an agency of the Federal Government and is being made available as a public service. Pursuant to title 17 United States Code Section 105, works of NIST employees are not subject to copyright protection in the United States.  This software may be subject to foreign copyright.  Permission in the United States and in foreign countries, to the extent that NIST may hold copyright, to use, copy, modify, create derivative works, and distribute this software and its documentation without fee is hereby granted on a non-exclusive basis, provided that this notice and disclaimer of warranty appears in all copies.
THE SOFTWARE IS PROVIDED 'AS IS' WITHOUT ANY WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE SOFTWARE WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND FREEDOM FROM INFRINGEMENT, AND ANY WARRANTY THAT THE DOCUMENTATION WILL CONFORM TO THE SOFTWARE, OR ANY WARRANTY THAT THE SOFTWARE WILL BE ERROR FREE.  IN NO EVENT SHALL NIST BE LIABLE FOR ANY DAMAGES, INCLUDING, BUT NOT LIMITED TO, DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES, ARISING OUT OF, RESULTING FROM, OR IN ANY WAY CONNECTED WITH THIS SOFTWARE, WHETHER OR NOT BASED UPON WARRANTY, CONTRACT, TORT, OR OTHERWISE, WHETHER OR NOT INJURY WAS SUSTAINED BY PERSONS OR PROPERTY OR OTHERWISE, AND WHETHER OR NOT LOSS WAS SUSTAINED FROM, OR AROSE OUT OF THE RESULTS OF, OR USE OF, THE SOFTWARE OR SERVICES PROVIDED HEREUNDER.
*/

import * as nn from "./nn";
import * as playground from "./playground";
import {Example2D} from "./dataset";


/**
 * This class is for computing network inefficiency using KL divergence of pairs of histograms
 * the histograms are created at each layer from the occurrence of possible outputs generated by all nodes in one layer
 * there is one histogram per layer and per output label (-1 or 1)
 * the KL divergence of data-driven histograms (probabilities) is computed against reference probabilities assumed to be
 * uniform but scaled based on ratios of training data point per label over all training data points
 *
 * @author Peter Bajcsy
 */
export class AppendingNetworkEfficiency {
  private number_classes: number;
  private netEfficiency_N: number[];
  private netEfficiency_P: number[];
  private arithmetic_avgKLdivergence: number;
  private geom_avgKLdivergence: number;
  private mapGlobal = null;
  // this is the sequence of states across layers per class label that occurs the most/lest frequently in each layer
  private stateCountMax_layer_label: number[][];
  private stateCountMin_layer_label: number[][];
  private stateKeyMax_layer_label: string[][];
  private stateKeyMin_layer_label: string[][];
  // this is the number of unique states utilized by each class label in the array across all layers
  private stateBinCount_layer_label: number[][];

  // number of states that are used by both classes at the same layer
  private stateOverlapCount_layer: number[];

  // these are the states that are used for predicting both P and N labels in each layer
  private stateLabelOverlap_layer: string[][];

  // the number of bits in all used states by the two classes that are uniquely split the classes
  private stateConstantBits_layer_label: string [][];

  constructor() {
    this.reset();
    this.number_classes = 2;
  }

  reset() {
      this.mapGlobal = [];
      this.netEfficiency_N = [];
      this.netEfficiency_P = [];
      this.stateOverlapCount_layer = [];
      this.stateBinCount_layer_label = [][this.number_classes ];// number of classes is 2
      this.stateCountMax_layer_label = [][this.number_classes ];
      this.stateCountMin_layer_label = [][this.number_classes ];
      this.stateKeyMax_layer_label = [][this.number_classes ];
      this.stateKeyMin_layer_label = [][this.number_classes ];
      this.arithmetic_avgKLdivergence = -1;
      this.geom_avgKLdivergence = -1;
      this.stateLabelOverlap_layer = [];
      this.stateConstantBits_layer_label = [];
  }

  public getMapGlobal():any[]{
    return this.mapGlobal;
  }

  public getStateLabelOverlap_layer():string[][]{
    return this.stateLabelOverlap_layer;
  }
  public getStateConstantBits_layer_label():string[][]{
    return this.stateConstantBits_layer_label;
  }

  public getStateBinCount_layer_label():number[][]{
    return this.stateBinCount_layer_label;
  }
  public getStateCountMax_layer_label():number[][]{
    return this.stateCountMax_layer_label;
  }
  public getStateCountMin_layer_label():number[][]{
    return this.stateCountMin_layer_label;
  }
  public getStateKeyMax_layer_label():string[][]{
    return this.stateKeyMax_layer_label;
  }
  public getStateKeyMin_layer_label():string[][]{
    return this.stateKeyMin_layer_label;
  }
  public getNetEfficiency_N():number[]{
    return this.netEfficiency_N;
  }
  public getNetEfficiency_P():number[]{
    return this.netEfficiency_P;
  }
  public getArithmeticAvgKLdivergence():number{
    return this.arithmetic_avgKLdivergence;
  }
  public getGeometricAvgKLdivergence():number{
    return this.geom_avgKLdivergence;
  }

  //////////////////////////////////////////////////////////////////////////////
  // TODO overlapping states and unique bits in states for discrimination of the two classes
  public computeLabelPredictionOverlap() {
    let map = this.getMapGlobal();
    // sanity check
    if(map == null ){
      console.log('ERROR: missing mapGlobal information about states');
      return;
    }
    if (Object.keys(map).length < 1){
      console.log('ERROR: Object.keys(map).length < 1 ');
      return;
    }

    let layerState_N: string []= [];
    let layerState_P: string []= [];
    let idx_N: number = 0;
    let idx_P: number = 0;
    let i, j, k: number;
    let countOverlap: number = 0; // this is the counter of overlapping states per layer
    let countConstantBits: number = 0; // this is the counter of teh constant bits per layer
    for (let layerIdx = 0; layerIdx < Object.keys(map).length; layerIdx++) {
      //split the map global into N and P label specific
      idx_N = idx_P = 0;
      countOverlap = 0;
      countConstantBits = 0;
      this.stateLabelOverlap_layer[layerIdx] = [];
      this.stateConstantBits_layer_label[layerIdx] = [];

      this.mapGlobal[layerIdx].forEach((value: number, key: string) => {

        if (key.substr(0, 1) === 'N') {
            // this is label N
            layerState_N[idx_N] = key.substr(2, key.length -1);
            idx_N++;
        }else{
          // this is label P
            layerState_P[idx_P] = key.substr(2, key.length -1);
            idx_P++;
        }
      });
      // find overlapping states
      for( i = 0; i < idx_N; i++){
        for( j = 0; j < idx_P; j++) {
          if (layerState_N[i].match(layerState_P[j])){
            // found match of the state that is used for predicting  P and N labels
            this.stateLabelOverlap_layer[layerIdx][countOverlap] = layerState_N[i];
            countOverlap ++;
            //console.log('INFO:layer: ' + layerIdx + ', overlapping state:' + layerState_N[i]);
          }
        }
      }
      /*
      // sanity check
      if(idx_N < 1 || idx_P < 1){
        console.log('INFO:layer: ' + layerIdx + ', predicts only one label - num N labels:' + idx_N + ', num P labels: ' + idx_P);
        return;
      }
       */
      // find constant bits across all states per label
      let bitHist: number [] = [];
      let oneBit: string;
      let numBits: number = layerState_N[0].length;

      //////////////////////////////////////
      // analyze label N for redundancy in the number of bits (i.e., number of nodes)
      for(k = 0; k < numBits; k++){
        bitHist[k] = 0;
      }
      for(i = 0; i < idx_N; i++){
        for(k = 0; k < numBits; k++){
          oneBit = layerState_N[i].substr(k,k+1);
          if( parseInt(oneBit) > 0 ) {
            // count the number of 1s in the k-th bit of the states 0 to idx_N
            bitHist[k]++;
          }
        }
      }
      for(k = 0; k < numBits; k++){
        //console.log('INFO: label N: bitHist[' + k + ']=' + bitHist[k] + ', idx_N:' + idx_N);
        if( bitHist[k] == 0) {
          // all k-th bit values in the states 0 to idx_N are equal to ZERO
          this.stateConstantBits_layer_label[layerIdx][countConstantBits] = 'N-' + k.toString() + '-' + '0';
          countConstantBits ++;
          //console.log('INFO: all ' + k + '-th bit values in the states 0 to ' + idx_N + ' are equal to ZERO');
        }
        if( bitHist[k] == idx_N ) {
          // all k-th bit values in the states 0 to idx_N are equal to ONE
          this.stateConstantBits_layer_label[layerIdx][countConstantBits] = 'N-' + k.toString() + '-' + '1';
          countConstantBits ++;
          //console.log('INFO: all ' + k + '-th bit values in the states 0 to ' + idx_N + ' are equal to ONE');
        }
      }
      //////////////////////////////////////
      // analyze label P for redundancy in the number of bits (i.e., number of nodes)
      for(k = 0; k < numBits; k++){
        bitHist[k] = 0;
      }
      for(i = 0; i < idx_P; i++){
        for(k = 0; k < numBits; k++){
          oneBit = layerState_P[i].substr(k,k+1);
          if( parseInt(oneBit) > 0 ) {
            // count the number of 1s in the k-th bit of the states 0 to idx_N
            bitHist[k]++;
          }
        }
      }
      for(k = 0; k < numBits; k++){
        //console.log('INFO: label P: bitHist[' + k + ']=' + bitHist[k] + ', idx_P:' + idx_P);
        if( bitHist[k] == 0) {
          // all k-th bit values in the states 0 to idx_P are equal to ZERO
          this.stateConstantBits_layer_label[layerIdx][countConstantBits] = 'P-' + k.toString() + '-' + '0';
          countConstantBits ++;
          //console.log('INFO: all ' + k + '-th bit values in the states 0 to ' + idx_P + ' are equal to ZERO');
        }
        if( bitHist[k] == idx_P ) {
          // all k-th bit values in the states 0 to idx_P are equal to ONE
          this.stateConstantBits_layer_label[layerIdx][countConstantBits] = 'P-' + k.toString() + '-' + '1';
          countConstantBits ++;
          //console.log('INFO: all ' + k + '-th bit values in the states 0 to ' + idx_P + ' are equal to ONE');
        }
      }


    }
  }

  /**
   * This method compute the inefficiency coefficient of each network layer
   * @param network
   * @param trainData
   */
  public getNetworkInefficiencyPerLayer(network: nn.Node[][],trainData:Example2D[]): boolean {
    //return array
    //let netEfficiency: number[] = [];

    /* configPts contains sequences of 0 and 1 (one per layer) that
    * correspond to each node output being 0 or 1 depending on the input point
    * mapGlobal contains the histogram of those sequences over all points per network layer  */
    //let mapGlobal = [];
    for (let idx = 0; idx < network.length - 1; idx++)
      this.mapGlobal[idx] = new Map<string, number>();

    let configPts;
    // finds stats of imbalanced data
    let countNOne: number = 0; //count negative label (minus one) labeled training data points
    let countPOne: number = 0; //count positive label (plus one) labeled training data points
    trainData.forEach((point, i) => {
      let input = playground.constructInput(point.x, point.y);
      //console.log('point:'+i +' val:' + input.toString() + ', label:' + point.label);
      // compute the output configuration at each layer per point
      configPts = nn.forwardNetEval(network, input);
      let output = nn.forwardProp(network, input);
      // assign hard label based on the predicted output probability
      let label: string;
      if (output <= 0) {
        label = 'N';
      } else {
        label = 'P';
      }
      // count the ground truth labels
      if (point.label <= 0) {
        countNOne++;
      } else {
        countPOne++;
      }
      //console.log('configPts:'+configPts.toString() + ', prob label:' + output.toString() + ', resulting label:' + label.toString());

      for (let layerIdx = 1; layerIdx < network.length; layerIdx++) {
        let temp = label + '-' + configPts[layerIdx - 1]; // configuration string
        let flag = false;
        if (this.mapGlobal[layerIdx - 1].size > 0) {
          if ((this.mapGlobal[layerIdx - 1]).get(temp) > 0) {
            flag = true;
            //console.log('match: ' + temp + ', stored:' + mapGlobal[layerIdx-1].get(temp));
          }
        }
        if (flag) {
          this.mapGlobal[layerIdx - 1].set(temp, this.mapGlobal[layerIdx - 1].get(temp) + 1);
        } else {
          this.mapGlobal[layerIdx - 1].set(temp, 1);
        }
      }
    });

    //sanity check
    // if(countNOne <= 0 || countPOne <= 0){
    //   console.log('ERROR: training data contains only one label from the two wanted labels.  countNOne:' + countNOne + ', countPOne:' + countPOne);
    //   let element = document.getElementById("KLdivergenceDiv");
    //   element.innerHTML = 'ERROR: training data contains only one label from the two wanted labels. countNOne:' + countNOne + ', countPOne:' + countPOne;
    //   return false;
    // }

    this.arithmetic_avgKLdivergence = 0.0;  // this is to compute arithmetic avg network KL divergence
    this.geom_avgKLdivergence = 1.0;  // this is to compute geometric avg network KL divergence

    // TODO remove the two variables
    // these two values are only for informative printout - not needed otherwise
    //let p_PLabel: number = countPOne/numEvalSamples; // probability of label P in the training data
    //let p_NLabel: number = countNOne/numEvalSamples; // probability of label N in the training data
    //console.log('countNOne:' + countNOne + ', countPOne:' + countPOne + ' p_PLabel:'+p_PLabel+', p_NLabel:'+p_NLabel);

    // init the array of states counts per layer and per label
    this.stateBinCount_layer_label = new Array(network.length-1).fill(0).map(() => new Array(this.number_classes).fill(0));

    this.stateCountMax_layer_label = new Array(network.length-1).fill(0).map(() => new Array(this.number_classes).fill(Number.MIN_SAFE_INTEGER));
    this.stateCountMin_layer_label = new Array(network.length-1).fill(0).map(() => new Array(this.number_classes).fill(Number.MAX_SAFE_INTEGER));

    this.stateKeyMax_layer_label = new Array(network.length-1).fill(0).map(() => new Array(this.number_classes).fill(''));
    this.stateKeyMin_layer_label = new Array(network.length-1).fill(0).map(() => new Array(this.number_classes).fill(''));

    for (let layerIdx = 0; layerIdx < network.length - 1; layerIdx++) {
      let currentLayerNodeCount = network[layerIdx + 1].length;
      // the number of 0 or 1 sequence outcomes from a layer with currentLayerNodeCount nodes is
      // equal to 2^(currentLayerNodeCount ) .
      let numBins: number =  Math.pow(2, currentLayerNodeCount); // this is n in the ppt slides

      let maxEntropy: number  = Math.log2(numBins);
      //console.log('maxEntropy for numBins:' + numBins + ' and currentLayerNodeCount:' + currentLayerNodeCount + ' is ' + maxEntropy);

      // define p_i for imbalanced classes
      // This number is multiplied by number of classes (equal to 2)  since the outcomes are associated with
      // one of the two possible class labels (or  numBins corresponds to only one possible outcome)
      let refProb_NOne: number = this.number_classes *  (1 / numBins);
      let refProb_POne: number = this.number_classes *  (1 / numBins);
      //console.log('refProb_NOne:' + refProb_NOne + ', refProb_POne:' + refProb_POne);

      //sanity check
      if (refProb_NOne <= 0 || refProb_POne <= 0) {
        console.log('ERROR: training data contains highly imbalanced labels refProb_NOne:' + refProb_NOne + ', refProb_POne:' + refProb_POne);
        this.netEfficiency_N[layerIdx] = 0;
        this.netEfficiency_P[layerIdx] = 0;
        let element = document.getElementById("KLdivergenceDiv");
        element.innerHTML = 'ERROR: training data contains highly imbalanced labels refProb_NOne:' + refProb_NOne + ', refProb_POne:' + refProb_POne;
        return false;
      }

      this.netEfficiency_N[layerIdx] = 0;
      this.netEfficiency_P[layerIdx] = 0;

      this.mapGlobal[layerIdx].forEach((value: number, key: string) => {
        let prob: number;
        //prob = value / ( numEvalSamples);
        if (key.substr(0, 1) === 'N') {
          // increment the number of states used up by the class label N
          this.stateBinCount_layer_label[layerIdx][0] ++;
          // find the min and max occurring state for the label N
          if(value > this.stateCountMax_layer_label[layerIdx][0] ){
            this.stateCountMax_layer_label[layerIdx][0] = value;
            this.stateKeyMax_layer_label[layerIdx][0] = key;
          }
          if(value < this.stateCountMin_layer_label[layerIdx][0]){
            this.stateCountMin_layer_label[layerIdx][0] = value;
            this.stateKeyMin_layer_label[layerIdx][0] = key;
          }
          // compute the q_ij probability
          prob = value / ( countNOne);
          this.netEfficiency_N[layerIdx] = this.netEfficiency_N[layerIdx] + prob * Math.log2(prob / refProb_NOne);
          //console.log('inside label N:' + key, value, prob);
          //console.log('N label - prob x log(ratio):' + (prob * Math.log2(prob / refProb_NOne)).toString());
        } else {
          // this is the case P class label
          //increment the number of states used up by the class label P
          this.stateBinCount_layer_label[layerIdx][1] ++;
          // find the min and max occurring state for the label N
          if(value > this.stateCountMax_layer_label[layerIdx][1] ){
            this.stateCountMax_layer_label[layerIdx][1] = value;
            this.stateKeyMax_layer_label[layerIdx][1] = key;
          }
          if(value < this.stateCountMin_layer_label[layerIdx][1]){
            this.stateCountMin_layer_label[layerIdx][1] = value;
            this.stateKeyMin_layer_label[layerIdx][1] = key;
          }
          // compute the probability q_ij
          prob = value / ( countPOne);
          this.netEfficiency_P[layerIdx] = this.netEfficiency_P[layerIdx] + prob * Math.log2(prob / refProb_POne);
          //console.log('inside label P:' + key, value, prob);
          //console.log('P label - prob x log(ratio):' + (prob * Math.log2(prob / refProb_POne)).toString());
        }
      });
       // this check is to alert about representation insufficiency of the layer with respect to the number of classes
      if (this.netEfficiency_N[layerIdx] < 0) {
        console.log('WARNING: layer:' + (layerIdx) + ', netEfficiency for N:' + this.netEfficiency_N[layerIdx] + ' is less than zero');
      }
      if (this.netEfficiency_P[layerIdx] < 0) {
        console.log('WARNING: layer:' + (layerIdx) + ', netEfficiency for P:' + this.netEfficiency_P[layerIdx] + ' is less than zero');
      }
      //console.log('layer:' + (layerIdx) + ': netEfficiency for N:' + this.netEfficiency_N[layerIdx] + ' and for P:'+ this.netEfficiency_P[layerIdx]);
      this.arithmetic_avgKLdivergence = this.arithmetic_avgKLdivergence + this.netEfficiency_N[layerIdx] + this.netEfficiency_P[layerIdx];
      this.geom_avgKLdivergence = this.geom_avgKLdivergence * (this.netEfficiency_N[layerIdx] + this.netEfficiency_P[layerIdx]);
    }

    // Note: this.netEfficiency_N.length = this.netEfficiency_P.length
    this.arithmetic_avgKLdivergence = this.arithmetic_avgKLdivergence / this.netEfficiency_N.length;
    //console.log('arithmetic avg. network efficiency:' + (Math.round(this.arithmetic_avgKLdivergence * 1000) / 1000).toString());

    this.geom_avgKLdivergence = Math.pow(this.geom_avgKLdivergence, (1.0/this.netEfficiency_N.length));
    //console.log('geometric avg. network efficiency:' + (Math.round(this.geom_avgKLdivergence * 1000) / 1000).toString());

    // testing purposes
/*    for(let k1=0;k1<this.stateBinCount_layer_label.length;k1++){ //
      for(let k2=0;k2<this.stateBinCount_layer_label[k1].length;k2++){
        console.log('stateBinCount['+k1+']['+k2+']='+this.stateBinCount_layer_label[k1][k2] + ", ");
        console.log('stateCountMax['+k1+']['+k2+']='+this.stateCountMax_layer_label[k1][k2] + ", ");
        console.log('stateKeyMax['+k1+']['+k2+']='+this.stateKeyMax_layer_label[k1][k2] + ", ");
        console.log('stateCountMin['+k1+']['+k2+']='+this.stateCountMin_layer_label[k1][k2] + ", ");
        console.log('stateKeyMin['+k1+']['+k2+']='+this.stateKeyMin_layer_label[k1][k2] + ", ");
      }
    }*/
    //////////////////////////////////////////////////////////////
    return true;
  }

  /**
   * this method converts the state bin count result for showing in HTML page
   *  This conversion function was replaced by the tablecharts class to make the results
   * more readable
   *
   * this code could be removed in the future
   */
  public convertStateBinCountToString(): string {
    let count_states_result: string = '';
    let stateBinCount_layer_label: number[][] = this.getStateBinCount_layer_label();
    // sanity check
    if(stateBinCount_layer_label == null){
      console.log("ERROR: missing stateBinCount_layer_label");
      return count_states_result;
    }
    for(let k1=0;k1<stateBinCount_layer_label.length;k1++){
      count_states_result += '&nbsp; layer:' + k1.toString() + ': ';
      for(let k2=0;k2<stateBinCount_layer_label[k1].length;k2++){
        if(k2 == 0) {
          count_states_result += ' Count of states for label: N: ' + stateBinCount_layer_label[k1][k2].toString() + ':';
        }else{
          count_states_result += ' Count of states for label: P: ' + stateBinCount_layer_label[k1][k2].toString() + ':';
        }
        //console.log('countState['+k1+']['+k2+']='+stateBinCount_layer_label[k1][k2] + ", ");
      }
      count_states_result += '<BR>';
    }
    return count_states_result;
  }

  /**
   * This method is for converting all frequency stats about most and least frequently aoccurring path
   * along depth of NN. This conversion function was replaced by the tablecharts class to make the results
   * more readable
   * @param MaxMin - input flaf 'Max' or 'Min' to indicate whether most (max) or least (min) frequently
   * results should be converted to a string
   *
   * this code could be removed in the future
   */
  public convertStatePath(MaxMin: string): string {
    let path_states_result: string = '';
    let printTextMax: string = ' Max Freq of the label-state: ';
    let printTextMin: string = ' Min Freq of the label-state: ';

    let stateCount_layer_label: number[][] ;
    let stateKey_layer_label: string[][];
    let printText: string;

    if(MaxMin == 'Max'){
      printText = printTextMax;
      stateCount_layer_label = this.getStateCountMax_layer_label();
      stateKey_layer_label = this.getStateKeyMax_layer_label();
    }else{
      printText = printTextMin;
      stateCount_layer_label = this.getStateCountMin_layer_label();
      stateKey_layer_label = this.getStateKeyMin_layer_label();
    }
    //sanity check
    if(stateCount_layer_label == null || stateKey_layer_label == null){
      console.log("ERROR: missing getStateCount_layer_label for " + MaxMin);
      return path_states_result;
    }
    for (let k1 = 0; k1 < stateCount_layer_label.length; k1++) { //
      path_states_result += '&nbsp; layer:' + k1.toString() + ': ';
      for (let k2 = 0; k2 < stateCount_layer_label[k1].length; k2++) {
        if (k2 == 0) {
          path_states_result += printText + stateKey_layer_label[k1][k2] + ': is :' + stateCount_layer_label[k1][k2].toString() + ':';
        } else {
          path_states_result += printText + stateKey_layer_label[k1][k2] + ': is :' + stateCount_layer_label[k1][k2].toString() + ':';
        }
        console.log(printText + ' state[' + k1 + '][' + k2 + ']=' + stateKey_layer_label[k1][k2] + ", max freq: " + stateCount_layer_label[k1][k2]);
      }
      path_states_result += '<BR>';
    }
    return path_states_result;
  }


}
